public MerchantResponse<String> mapEntity(UserEntityMappingRequest userEntityMappingRequest) {
        log.info("Step 1: Received request to map entity with details: {}", userEntityMappingRequest);

        // Step 1: Validate the request
        log.info("Step 2: Validating the UserEntityMappingRequest");
        userEntityValidator.UserEntityRequestValidator(userEntityMappingRequest);

        // Step 2: Retrieve the user
        MerchantUserDto userDto = retrieveUser(userEntityMappingRequest);

        // Step 3: Perform action based on user role
        adminDao.UpdateUserRole(userDto, userEntityMappingRequest.getEntityId());

        // Step 4: Build and return the response
        return MerchantResponse.<String>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of("user role updated")).count(1L).total(1L).build();
    }

    /**
     * Retrieves the user based on userId or userName in the request.
     */
    private MerchantUserDto retrieveUser(UserEntityMappingRequest userEntityMappingRequest) {
        log.info("Step 3: Retrieving user based on request details");
        return userEntityMappingRequest.getUserId() != null
                ? adminDao.findByUserId(userEntityMappingRequest.getUserId())
                : adminDao.findByUserNameOrEmailOrMobilePhone(
                userEntityMappingRequest.getUserName(),
                userEntityMappingRequest.getUserName(),
                userEntityMappingRequest.getUserName());
    }


package com.epay.merchant.validator;

import com.epay.merchant.dao.AdminDao;
import com.epay.merchant.dao.MerchantUserDao;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.dto.MerchantUserDto;
import com.epay.merchant.entity.MerchantUser;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.model.request.UserEntityMappingRequest;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.enums.MerchantStatus;
import com.epay.merchant.util.enums.MerchantUserRoles;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Component;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Optional;
import java.util.UUID;


@Component
@RequiredArgsConstructor
public class UserEntityValidator extends BaseValidator {

    private final AdminDao adminDao;
    private final MerchantUserDao merchantUserDao ;

    public void UserEntityRequestValidator(UserEntityMappingRequest userEntityMappingRequest){
        errorDtoList = new ArrayList<>();
        validateMandatoryFields(userEntityMappingRequest);
        boolean isUserNamePresent = StringUtils.isNotEmpty(userEntityMappingRequest.getUserName());
        boolean isUserIdPresent = ObjectUtils.isNotEmpty(userEntityMappingRequest.getUserId());
        validateValues(isUserNamePresent, isUserIdPresent);
        MerchantUser merchantUser;
        MerchantUserDto merchantUserDto;
        if(isUserNamePresent && adminDao.isMerchantUserExist(userEntityMappingRequest.getUserName(), userEntityMappingRequest.getUserName(), userEntityMappingRequest.getUserName())){
            merchantUserDto = merchantUserDao.findByUserNameOrEmailOrMobilePhone(userEntityMappingRequest.getUserName(), userEntityMappingRequest.getUserName(), userEntityMappingRequest.getUserName());
            statusCheck(merchantUserDto.getStatus().name());
            roleValidator(merchantUserDto.getId());
        }else{
            merchantUser = merchantUserDao.findByUserId(userEntityMappingRequest.getUserId()).orElseThrow(() -> new MerchantException(ErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(ErrorConstants.INVALID_ERROR_MESSAGE,"user", "user not present")));
            statusCheck(merchantUser.getStatus());
            roleValidator(merchantUser.getId());
        }
        validateEntityId(userEntityMappingRequest.getEntityId());
    }

    private void validateMandatoryFields(UserEntityMappingRequest userEntityMappingRequest){
        checkMandatoryField(userEntityMappingRequest.getEntityId(), "entity Id");
        throwIfErrors();
    }

    private void validateValues(boolean isUserNamePresent, boolean isUserIdPresent){
        if(isUserNamePresent == isUserIdPresent){
            errorDtoList.add(ErrorDto.builder().errorCode(ErrorConstants.MANDATORY_FOUND_ERROR_CODE).errorMessage(MessageFormat.format(ErrorConstants.MANDATORY_ERROR_MESSAGE, "value of userName or UserId")).build());
        }
    }

    private void statusCheck(String status){
        if(!MerchantStatus.ACTIVE.name().equals(status)){
            errorDtoList.add(ErrorDto.builder().errorCode(ErrorConstants.INVALID_ERROR_CODE).errorMessage(MessageFormat.format(ErrorConstants.INVALID_ERROR_MESSAGE, "status", "Reason : status should be active")).build());
        }
    }

    private void validateEntityId(String entityId){
        if(!adminDao.isEntityIdPresent(entityId)){
            errorDtoList.add(ErrorDto.builder().errorCode(ErrorConstants.INVALID_ERROR_CODE).errorMessage(MessageFormat.format(ErrorConstants.INVALID_ERROR_MESSAGE, "entity Id", "Reason : entity Id is not present")).build());
        }
        throwIfErrors();
    }

    private void roleValidator(UUID userId){
        if(!MerchantUserRoles.SUPER_ADMIN.name().equals(adminDao.findUserRoleByUserId(userId)) && !MerchantUserRoles.ADMIN.name().equals(adminDao.findUserRoleByUserId(userId))){
            errorDtoList.add(ErrorDto.builder().errorCode(ErrorConstants.INVALID_ERROR_CODE).errorMessage(MessageFormat.format(ErrorConstants.INVALID_ERROR_MESSAGE, "role", "Reason : only ADMIN and SUPER_ADMIN are allowed")).build());
        }
    }
}


public String findUserRoleByUserId(UUID id) {
        return merchantUserRepository.findUserRoleByUserId(id);
    }

    public void UpdateUserRole(MerchantUserDto userDto, String entityId) {
        String userRole = findUserRoleByUserId(userDto.getId());
        if (MerchantUserRoles.SUPER_ADMIN.name().equals(userRole)) {
            log.info("User is a SUPER_ADMIN. Updating entityId for userId: {}", userDto.getId());
            merchantEntityUserRepository.updateEntityIdForUser(userDto.getId(), entityId);
        } else if (MerchantUserRoles.ADMIN.name().equals(userRole)) {
            log.info("User is an ADMIN. Upgrading role and saving entityId for userId: {}", userDto.getId());
            findOrSaveMerchantUser(userDto, entityId);
        }
    }

    public void findOrSaveMerchantUser(MerchantUserDto merchantUserDto, String entityId) {
        MerchantUser merchantUser = mapper.mapMerchantUserDtoToEntity(merchantUserDto);
        UUID roleId = findRoleIdByRoleName(MerchantUserRoles.SUPER_ADMIN.name());
        merchantUser.setRole(roleId);
        merchantUser = merchantUserRepository.save(merchantUser);
        merchantEntityUserRepository.deleteByUserId(merchantUser.getId());
        MerchantEntityUser newEntityUser = MerchantEntityUser.builder().userId(merchantUser.getId()).entityId(entityId).mId(merchantEntityGroupRepository.findByEntityId(entityId).getMId()).build();
        merchantEntityUserRepository.save(newEntityUser);
        updateUserMenuPermission(merchantUser.getId(), roleId);
    }

.....................

import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

public class UserMapperTest {

    @Test
    public void testMapToDTO_ValidEntity() {
        // Arrange
        UserEntity entity = new UserEntity();
        entity.setId(1L);
        entity.setName("John Doe");
        entity.setEmail("john.doe@example.com");

        // Act
        UserDTO dto = UserMapper.mapToDTO(entity);

        // Assert
        assertNotNull(dto);
        assertEquals(entity.getId(), dto.getId());
        assertEquals(entity.getName(), dto.getName());
    }

    @Test
    public void testMapToDTO_NullEntity() {
        // Act
        UserDTO dto = UserMapper.mapToDTO(null);

        // Assert
        assertNull(dto);
    }
}


