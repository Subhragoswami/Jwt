package com.epay.merchant.service;

import com.epay.merchant.dao.KeyDao;
import com.epay.merchant.document.pdf.PDFService;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.externalservice.response.KMSAPIKeysResponse;
import com.epay.merchant.externalservice.response.KMSEncryptionKeysResponse;
import com.epay.merchant.externalservice.response.KMSKeyResponse;
import com.epay.merchant.model.request.APIKeyValidationRequest;
import com.epay.merchant.model.request.KeyGenerationRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.util.MerchantUtil;
import com.epay.merchant.util.PasswordGenerator;
import com.epay.merchant.util.enums.KeyType;
import com.epay.merchant.validator.KeyValidator;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.text.MessageFormat;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;


/**
 * Class Name: KeyService
 * *
 * Description:
 * *
 * Author: V1017903(bhushan wadekar)
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */

@Service
@RequiredArgsConstructor
public class KeyService {

    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());
    private final KeyValidator keyValidator;
    private final KeyDao keyDao;
    private final PasswordGenerator passwordGenerator;
    private final PDFService pdfService;

    /**
     * Handles the generation of keys (API or Encryption) for merchants.
     * Logs details about the key generation process and errors, if any.
     *
     * @param type                 KeyType The type of key to generate (API or Encryption).
     * @param keyGenerationRequest keyGenerationRequest Request body containing key generation details.
     * @param response             HttpServletResponse HTTP response object for sending the generated file.
     */
    public void generateKey(KeyType type, KeyGenerationRequest keyGenerationRequest, HttpServletResponse response) {
        logger.info("Started generateKey for type: {}", type);
        ByteArrayOutputStream pdfStream;
        // Step 1 : Validate the KMSKeyGenerationRequest
        keyValidator.validateKeyGenerationRequest(keyGenerationRequest);
        switch (type) {
            case API -> pdfStream = apiKeyGeneration(keyGenerationRequest);
            case ENCRYPTION -> pdfStream = encryptionKeyGeneration(keyGenerationRequest);
            default -> {
                logger.error("Invalid KeyType provided: {}", type);
                throw new MerchantException(ErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(ErrorConstants.INVALID_ERROR_MESSAGE, "KeyType", "Valid Key Type are " + Arrays.toString(KeyType.values())));
            }
        }
        fileResponse(type, keyGenerationRequest, response, pdfStream);
        logger.info("Completed generateKey for type: {}", type);
    }

    /**
     * Validates an API key and returns the validation status.
     * Logs the validation process and potential errors.
     *
     * @param apiKeyValidationRequest APIKeyValidationRequest Request body containing API key validation details.
     * @return MerchantResponse containing validation status.
     */
    public MerchantResponse<String> validatedAPIKey(APIKeyValidationRequest apiKeyValidationRequest) {
        logger.info("Started validatedAPIKey for request: {}", apiKeyValidationRequest);
        keyValidator.validateAPIKeyValidationRequest(apiKeyValidationRequest);
        logger.info("Validation of validatedAPIKey Completed for request: {}", apiKeyValidationRequest);
        return keyDao.validatedAPIKey(apiKeyValidationRequest);
    }

    /**
     * Retrieves encryption keys for a given merchant ID.
     * Logs the retrieval process and potential errors.
     *
     * @param mId String Merchant ID for which encryption keys are fetched.
     * @return MerchantResponse containing encryption key details.
     */
    public MerchantResponse<KMSEncryptionKeysResponse> getMerchantEncryptionKeys(String mId) {
        logger.info("Started getMerchantEncryptionKeys for a merchant: {}", mId);
        keyValidator.validateMId(mId);
        logger.info("Completed getMerchantEncryptionKeys for merchant {}", mId);
        return keyDao.getMerchantEncryptionKeys(mId);
    }

    /**
     * This method generates an encryption key and creates a pwd-protected PDF file.
     *
     * @param keyGenerationRequest KeyGenerationRequest The request object containing key generation details
     * @return ByteArrayOutputStream containing the generated PDF file
     */
    private ByteArrayOutputStream encryptionKeyGeneration(KeyGenerationRequest keyGenerationRequest) {
        logger.info("Started encryptionKeyGeneration for request: {}", keyGenerationRequest);
        // Step 1 : Call the KMS APIs
        KMSEncryptionKeysResponse kmsEncryptionKeysResponse = keyDao.generateEncryptionKey(keyGenerationRequest);
        // Step 2 : Generate the pwd-protected PDF File
        return pdfFileGenerator(keyGenerationRequest.getMId(), kmsEncryptionKeysResponse.getMek(), kmsEncryptionKeysResponse.getId());
    }

    /**
     * This method generates an API Key and creates a pwd-protected PDF file.
     *
     * @param keyGenerationRequest KeyGenerationRequest The request object containing API key generation details
     * @return ByteArrayOutputStream containing the generated PDF file
     */
    private ByteArrayOutputStream apiKeyGeneration(KeyGenerationRequest keyGenerationRequest) {
        logger.info("Started apiKeyGeneration for request: {}", keyGenerationRequest);
        // Step 1 : Call the KMS APIs
        KMSAPIKeysResponse kmsapiKeysResponse = keyDao.generateApiKey(keyGenerationRequest.getMId());
        // Step 2 : Generate the pwd-protected PDF File
        return apiPdfFileGenerator(keyGenerationRequest.getMId(), kmsapiKeysResponse.getApiKey(), kmsapiKeysResponse.getApiKeySecret(), kmsapiKeysResponse.getId());
    }

    /**
     * Fetches the keys associated with a given merchant ID and key type.
     * Logs the retrieval process and any errors encountered.
     *
     * @param keyType  Key type to filter (API or Encryption).
     * @param mId      String Merchant ID for which keys are fetched.
     * @param pageable Pageable object for pagination.
     * @return MerchantResponse containing the list of keys.
     */
    public MerchantResponse<KMSKeyResponse> getKeysByMerchant(KeyType keyType, String mId, Pageable pageable) {
        logger.info("Fetching key by merchant keyType: {}, mId: {}", keyType, mId);
        return keyDao.getKeysByMerchant(keyType, mId, pageable);
    }

    /**
     * This method retrieves a Encryption key for the given Merchant ID (mId),
     * generates a pwd-protected PDF, and sends it as a downloadable response.
     *
     * @param mId      Merchant ID for which the decryption key is to be fetched.
     * @param response HttpServletResponse object to send the generated PDF as a response.
     */
    public void getMerchantEncryptionKeysForDownload(String mId, HttpServletResponse response) {
        // Step 1: validate the mId
        keyValidator.validateMId(mId);
        // Step 2: Fetch the decrypted key
        String mek = keyDao.getMerchantEncryptionKeysForDownload(mId);
        // Step 3: Generate a pwd for the PDF
        ByteArrayOutputStream pdfStream = pdfFileGenerator(mId, mek, UUID.randomUUID());
        fileResponse(KeyType.ENCRYPTION, KeyGenerationRequest.builder().mId(mId).build(), response, pdfStream);
    }

    /**
     * This method writes the generated PDF file to the HTTP response.
     *
     * @param keyGenerationRequest KeyGenerationRequest  The request object containing key generation details
     * @param type                 KeyType The type of key to generate (API or Encryption).
     * @param response             HttpServletResponse the HttpServletResponse to send the PDF file
     * @param pdfStream            ByteArrayOutputStream  containing the generated PDF data
     */
    protected void fileResponse(KeyType type, KeyGenerationRequest keyGenerationRequest, HttpServletResponse response, ByteArrayOutputStream pdfStream) {
        logger.info("Started fileResponse for type: {}, request: {}", type, keyGenerationRequest);
        try {
            String fileName = type.name() + "_" + keyGenerationRequest.getMId() + "_" + System.currentTimeMillis() + ".pdf";
            MerchantUtil.setHeader(response, MediaType.APPLICATION_PDF_VALUE, fileName);
            response.getOutputStream().write(pdfStream.toByteArray());
            response.getOutputStream().flush();
            logger.info("Completed fileResponse for type: {}, request: {}", type, keyGenerationRequest);
        } catch (IOException e) {
            logger.error("Error in PDF File Generation ", e);
            throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE, MessageFormat.format(ErrorConstants.GENERATION_ERROR_MESSAGE, type.name() + "Key"));
        }
    }

    /**
     *
     * @param mId String
     * @param mek String
     * @param id UUID
     * @return ByteArrayOutputStream
     */
    protected ByteArrayOutputStream pdfFileGenerator(String mId, String mek, UUID id) {
        String password = passwordGenerator.generatePassword();
        Map<String, String> input = new HashMap<>();
        input.put(MerchantConstant.MEK,mek);
        ByteArrayOutputStream byteArrayOutputStream = pdfService.generatedPDF(input, password,"encryption_key");
        // Step 3 : Send Notification to Merchant
        keyDao.saveNotification(KeyType.ENCRYPTION, id, "Encryption Key PDF file Password is :" + password, mId);
        logger.info("File Generate for encryptionKey");
        return byteArrayOutputStream;
    }

    protected ByteArrayOutputStream apiPdfFileGenerator(String mId, String ApiKey, String KeySecret, UUID id) {
        String password = passwordGenerator.generatePassword();
        Map<String, String> input = new HashMap<>();
        input.put(MerchantConstant.API_KEY,ApiKey);
        input.put(MerchantConstant.API_KEY_SECRET,KeySecret);
        ByteArrayOutputStream byteArrayOutputStream = pdfService.generatedPDF(input, password,"api_key");
        // Step 3 : Send Notification to Merchant
        keyDao.saveNotification(KeyType.ENCRYPTION, id, "Encryption Key PDF file Password is :" + password, mId);
        logger.info("File Generate for encryptionKey");
        return byteArrayOutputStream;
    }

}
@Data
@Builder
public class KeyGenerationRequest {

    @JsonProperty("mId")
    @Schema(description = "Merchant ID", example = "MID7")
    @NotBlank(message = MANDATORY_FIELD)
    private String mId;
    @Schema(description = "oldKeyExpiryInHr", example = "30")
    private int oldKeyExpiryInHr;
}
 public KMSAPIKeysResponse generateApiKey(String mId) {
        try {
            MerchantResponse<KMSAPIKeysResponse> kmsResponse = kmsClient.generateAPIKeys(mId, merchantConfig.getApiKeyExpiryTime());
            if (kmsResponse.getStatus() == MerchantConstant.RESPONSE_SUCCESS && CollectionUtils.isNotEmpty(kmsResponse.getData())) {
                UUID keyId = saveKey(mId, KeyType.API, MerchantConstant.RESPONSE_SUCCESS, API_KEY_GENERATED);
                KMSAPIKeysResponse kmsapiKeysResponse = kmsResponse.getData().getFirst();
                kmsapiKeysResponse.setId(keyId);
                return kmsapiKeysResponse;
            } else if (kmsResponse.getStatus() == MerchantConstant.RESPONSE_FAILURE) {
                saveKey(mId, KeyType.API, MerchantConstant.RESPONSE_FAILURE, Arrays.toString(kmsResponse.getErrors().toArray(new ErrorDto[0])));
                throw new ValidationException(kmsResponse.getErrors());
            }
            saveKey(mId, KeyType.API, MerchantConstant.RESPONSE_FAILURE, ERROR_IN_API_KEY_GENERATED);
            throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE, MessageFormat.format(ErrorConstants.GENERATION_ERROR_MESSAGE, API_KEY));
        } catch (Exception e) {
            log.error("Error in API Key Generation : ", e);
            saveKey(mId, KeyType.API, MerchantConstant.RESPONSE_FAILURE, ERROR_IN_API_KEY_GENERATED + e.getMessage());
            throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE, MessageFormat.format(ErrorConstants.GENERATION_ERROR_MESSAGE, API_KEY));
        }
    }
    public ByteArrayOutputStream generatedPDF(Map<String, String> input, String pwd, String template) {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        // Write the PDF content to the response output stream
        try {
            logger.debug("Rendering PDF content for template: {}", template);
            ITextRenderer renderer = new ITextRenderer();
            renderer.setDocumentFromString(getPdfContent(input, template));
            renderer.layout();
            renderer.createPDF(outputStream);
            securePdf(outputStream, pwd);
            logger.info("PDF generated and written to response successfully.");
        } catch (Exception e) {
            logger.error("An error occurred in downloadPdfFile method: {}", e.getMessage());
            throw new MerchantException(ErrorConstants.FILE_GENERATION_ERROR_CODE, MessageFormat.format(ErrorConstants.FILE_GENERATION_ERROR_MESSAGE, "pdf", e.getMessage()));
        }
        return outputStream;
    }
  private String getPdfContent(Map<String, String> input, String template) {
        logger.debug("Processing PDF content for template: {}", template);
        Context context = new Context();
        context.setVariable(MerchantConstant.MAP, input);
        return templateEngine.process(template, context);
    }

please write JUnit for this methods

    private ByteArrayOutputStream apiKeyGeneration(KeyGenerationRequest keyGenerationRequest) {
        logger.info("Started apiKeyGeneration for request: {}", keyGenerationRequest);
        // Step 1 : Call the KMS APIs
        KMSAPIKeysResponse kmsapiKeysResponse = keyDao.generateApiKey(keyGenerationRequest.getMId());
        // Step 2 : Generate the pwd-protected PDF File
        return apiPdfFileGenerator(keyGenerationRequest.getMId(), kmsapiKeysResponse.getApiKey(), kmsapiKeysResponse.getApiKeySecret(), kmsapiKeysResponse.getId());
    }

    protected ByteArrayOutputStream apiPdfFileGenerator(String mId, String ApiKey, String KeySecret, UUID id) {
        String password = passwordGenerator.generatePassword();
        Map<String, String> input = new HashMap<>();
        input.put(MerchantConstant.API_KEY,ApiKey);
        input.put(MerchantConstant.API_KEY_SECRET,KeySecret);
        ByteArrayOutputStream byteArrayOutputStream = pdfService.generatedPDF(input, password,"api_key");
        // Step 3 : Send Notification to Merchant
        keyDao.saveNotification(KeyType.ENCRYPTION, id, "Encryption Key PDF file Password is :" + password, mId);
        logger.info("File Generate for encryptionKey");
        return byteArrayOutputStream;
    }
