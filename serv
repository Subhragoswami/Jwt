
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

public class Test {
    public static void main(String[] args) {
        Long time = calculateDateByFrequency(Frequency.MONTHLY, "8:28 PM");
        System.out.println(time);
    }

    public static Long calculateDateByFrequency(Frequency frequency, String time) {
        // Parse the input time string into a LocalTime object
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("h:mm a");
        LocalTime reqTime = LocalTime.parse(time.trim().toLowerCase(Locale.ROOT), formatter);

        LocalDateTime now = LocalDateTime.now();
        LocalDateTime nextDateTime;
        
        switch (frequency) {
            case DAILY:
                nextDateTime = now.toLocalTime().isAfter(reqTime) 
                    ? LocalDateTime.of(now.toLocalDate().plusDays(1), reqTime)
                    : LocalDateTime.of(now.toLocalDate(), reqTime);
                break;

            case MONTHLY:
                // Ensure the day is valid for the next month
                int dayOfMonth = now.getDayOfMonth(); // Get current day of the month
                LocalDate nextMonth = now.plusMonths(1).toLocalDate();
                int lastDayOfMonth = nextMonth.lengthOfMonth(); // Get last day of the next month

                // Adjust the day if it exceeds the last day of the next month
                dayOfMonth = Math.min(dayOfMonth, lastDayOfMonth); 

                // Set the next date-time with adjusted day
                nextDateTime = now.toLocalTime().isAfter(reqTime)
                    ? LocalDateTime.of(nextMonth.withDayOfMonth(dayOfMonth), reqTime)
                    : LocalDateTime.of(nextMonth.withDayOfMonth(dayOfMonth), reqTime);
                break;

            case YEARLY:
                nextDateTime = now.toLocalTime().isAfter(reqTime)
                    ? LocalDateTime.of(now.plusYears(1), reqTime)
                    : LocalDateTime.of(now.withDayOfYear(1), reqTime);
                break;

            default:
                throw new IllegalArgumentException("Invalid Frequency: " + frequency);
        }

        // Print the calculated date in milliseconds
        return nextDateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
    }
}

enum Frequency {
    DAILY,
    MONTHLY,
    YEARLY
}