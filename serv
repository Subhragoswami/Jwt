/*
 *
 *  Copyright (c) [2024] [State Bank of India]
 *  All rights reserved.
 *
 *  Author:@V0000001(Shilpa Kothre)
 *  Version:1.0
 *
 */


package com.epay.kms.exceptionhandlers;


import com.epay.kms.dto.ErrorDto;
import com.epay.kms.exception.KeyManagementException;
import com.epay.kms.model.response.KMSResponse;
import com.epay.kms.util.ErrorConstant;
import com.epay.kms.util.KmsConstant;
import com.sbi.epay.encryptdecrypt.exception.EncryptionDecryptionException;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
import org.springframework.web.servlet.resource.NoResourceFoundException;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;

import static com.epay.kms.util.ErrorConstant.INVALID_ERROR_CODE;
import static com.epay.kms.util.ErrorConstant.INVALID_ERROR_MESSAGE;

/**
 * Class Name: KMSExceptionHandler
 * *
 * Description: This class handles global exception.
 * *
 * Author: V1017903(bhushan wadekar)
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
@ControllerAdvice
public class KMSExceptionHandler {
    LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());

    @ExceptionHandler(value = {KeyManagementException.class})
    public ResponseEntity<Object> handleKMSException(KeyManagementException ex) {
        ErrorDto errorDto = ErrorDto.builder().errorCode(ex.getErrorCode()).errorMessage(ex.getErrorMessage()).build();
        return generateResponseWithErrors(List.of(errorDto));
    }

    @ExceptionHandler(value = {EncryptionDecryptionException.class})
    public ResponseEntity<Object> handleEncryptionDecryptionException(EncryptionDecryptionException ex) {
        ErrorDto errorDto = ErrorDto.builder().errorCode(ex.getErrorCode()).errorMessage(ex.getErrorMessage()).build();
        return generateResponseWithErrors(List.of(errorDto));
    }

    /**
     * Handle handleMethodArgumentTypeMismatch
     *
     * @param ex MethodArgumentTypeMismatchException
     * @return ResponseEntity
     */
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<Object> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        logger.error("Error in handleMethodArgumentTypeMismatch with message: {}", ex.getMessage());
        ErrorDto errorDto = ErrorDto.builder().errorCode(INVALID_ERROR_CODE).errorMessage(MessageFormat.format(INVALID_ERROR_MESSAGE, ex.getPropertyName(), ex.getValue() + " is not a valid input.")).build();
        return generateResponseWithErrors(List.of(errorDto));
    }

    /**
     * Handle ResourceException
     *
     * @param ex NoResourceFoundException
     * @return ResponseEntity
     */
    @ExceptionHandler(NoResourceFoundException.class)
    public ResponseEntity<Object> handleResourceException(NoResourceFoundException ex) {
        logger.error("Error in handleResourceException for resource: {}, message: {}", ex.getResourcePath(), ex.getMessage());
        ErrorDto errorDto = ErrorDto.builder().errorCode(INVALID_ERROR_CODE).errorMessage(MessageFormat.format(INVALID_ERROR_MESSAGE, ex.getResourcePath(), ex.getResourcePath() + " is not a valid url.")).build();
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(KMSResponse.builder().status(KmsConstant.RESPONSE_FAILURE).errors(List.of(errorDto)).build());
    }


    @ExceptionHandler(value = {Exception.class})
    public ResponseEntity<Object> handleGenericException(Exception ex) {
        logger.error("Error in handleGenericException ", ex);
        ErrorDto errorDto = ErrorDto.builder().errorCode(INVALID_ERROR_CODE).errorMessage(ex.getMessage()).build();
        return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).body(KMSResponse.builder().status(KmsConstant.RESPONSE_FAILURE).errors(List.of(errorDto)).build());
    }

    @ExceptionHandler(value = {MethodArgumentNotValidException.class})
    protected ResponseEntity<Object> handleValidationException(MethodArgumentNotValidException ex) {
        logger.error("Error in handleValidationException with message: {}", ex.getMessage());
        List<ErrorDto> errors = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(fieldError -> errors.add(ErrorDto.builder().errorCode(ErrorConstant.KMS_ERROR_CODE).errorMessage(fieldError.getField() + ":" + fieldError.getDefaultMessage()).build()));
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(KMSResponse.builder().status(KmsConstant.RESPONSE_FAILURE).errors(errors).build());
    }

    @ExceptionHandler(value = {IllegalArgumentException.class})
    protected ResponseEntity<Object> handleConflict(RuntimeException ex) {
        logger.error("Error in handleConflict ", ex);
        ErrorDto errorDto = ErrorDto.builder().errorCode(String.valueOf(HttpStatus.CONFLICT.value())).errorMessage(ex.getMessage()).build();
        return ResponseEntity.status(HttpStatus.CONFLICT).body(KMSResponse.builder().status(KmsConstant.RESPONSE_FAILURE).errors(List.of(errorDto)).build());
    }

    private ResponseEntity<Object> generateResponseWithErrors(List<ErrorDto> errors) {
        return ResponseEntity.ok().body(KMSResponse.builder().status(KmsConstant.RESPONSE_FAILURE).errors(errors).build());
    }

    /**
     * Handle EnumConversionException
     *
     * @param e MethodArgumentTypeMismatchException
     * @return ResponseEntity
     */
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<Object> handleEnumConversionException(HttpMessageNotReadableException e) {
        logger.error("Error in handleEnumConversionException with message: {}", e.getMessage());
        ErrorDto errorDto = ErrorDto.builder().errorCode(INVALID_ERROR_CODE).errorMessage(e.getMessage()).build();
        return generateResponseWithErrors(List.of(errorDto));
    }


}

for this if I do post call to get call it
s not throwing get is not suppported

@Data
@Builder
public class APIKeyValidationRequest {
    @NotBlank(message = "API Key is mandatory")
    private String apiKey;
    @NotBlank(message = "API KeySecret is mandatory")
    private String apiKeySecret;
}

instead of that it's throwing {
    "status": 0,
    "errors": [
        {
            "errorCode": "7022",
            "errorMessage": "Invalid keyType. Reason : validated is not a valid input."
        }
    ]
}
