@Component
@RequiredArgsConstructor
public class KMSValidator extends BaseValidator{
    

    public void validateKeyGenerationRequest(KeyGenerationRequest keyGenerationRequest){
        validateMid(keyGenerationRequest.getMId());
    }

    public void validateMid(String mId) {
        validateFieldWithRegex(mId, 7, MID_REGEX, MID, INVALID_FORMAT_OR_MAX_LEN_ERROR_MESSAGE);
        throwIfErrors();
    }

}
package com.epay.kms.Validator;

import com.epay.kms.dto.ErrorDto;
import com.epay.kms.exception.ValidationException;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.EnumUtils;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;

import java.text.MessageFormat;
import java.util.*;
import java.util.regex.Pattern;

import static com.epay.kms.util.ErrorConstant.*;

public class BaseValidator {

    List<ErrorDto> errorDtoList;

    /**
     * Check mandatory field
     * @param value String
     * @param fieldName String
     */
    protected void checkMandatoryField(String value, String fieldName) {
        if (StringUtils.isEmpty(value) || StringUtils.equals(value,"null")) {
            addError(fieldName, MANDATORY_ERROR_CODE, MANDATORY_ERROR_MESSAGE);
        }
    }

    /**
     * Check mandatory field
     * @param value UUID
     * @param fieldName String
     */
    protected void checkMandatoryField(UUID value, String fieldName) {
        if (ObjectUtils.isEmpty(value)) {
            addError(fieldName, MANDATORY_ERROR_CODE, MANDATORY_ERROR_MESSAGE);
        }
    }

    /**
     * Check mandatory collection
     * @param collection Collection
     * @param fieldName String
     */
    protected void checkMandatoryCollection(Collection<?> collection, String fieldName) {
        if (CollectionUtils.isEmpty(collection)) {
            addError(fieldName, MANDATORY_ERROR_CODE, MANDATORY_ERROR_MESSAGE);
        }
    }

    /**
     * Check mandatory fields
     * @param fieldName String
     * @param values String...
     */
    protected void checkMandatoryFields(String fieldName, String... values) {
        boolean allEmpty = Arrays.stream(values).allMatch(StringUtils::isEmpty);
        if (allEmpty) {
            addError(fieldName, MANDATORY_ERROR_CODE, MANDATORY_ERROR_MESSAGE);
        }
    }

    /**
     * Check mandatary date field
     * @param date Long
     * @param fieldName String
     */
    protected void checkMandatoryDateField(Long date, String fieldName) {
        if (ObjectUtils.isEmpty(date) || date < 0) {
            addError(fieldName, MANDATORY_ERROR_CODE, MANDATORY_ERROR_MESSAGE);
        }
    }

    protected void validateFieldLength(String value, int maxLength, String fieldName) {
        if (StringUtils.isNotEmpty(value) && value.length() > maxLength) {
            addError(MAX_ALLOWED_LENGTH_ERROR_CODE, MAX_ALLOWED_LENGTH_ERROR_MESSAGE, fieldName, maxLength);
        }
    }

    protected void validateFieldWithRegex(String value, int maxLength, String regex, String fieldName, String message) {
        if (StringUtils.isNotEmpty(value) && (value.length() > maxLength || validate(value, regex))) {
            addError(fieldName, INVALID_FORMAT_OR_MAX_LEN_ERROR_CODE, message + " " + maxLength);
        }
    }
//
//    protected void validateFieldWithRegex(String value, String regex, String fieldName, String message) {
//        if (StringUtils.isNotEmpty(value) && validate(value, regex)) {
//            addError(fieldName, INVALID_FORMAT_ERROR_CODE, MessageFormat.format(message, fieldName, value));
//        }
//    }

    protected void validateFieldValue(String value, String validValue, String fieldName) {
        if (!validValue.equalsIgnoreCase(value)) {
            addError(INVALID_ERROR_CODE, INVALID_ERROR_MESSAGE, fieldName, VALID_VALUES_ARE + validValue);
        }
    }

    protected void validateFieldValue(String value, List<String> validValues, String fieldName) {
        boolean isValid = validValues.stream().anyMatch(validValue -> validValue.equalsIgnoreCase(value));
        if (!isValid) {
            addError(INVALID_ERROR_CODE, INVALID_ERROR_MESSAGE, fieldName, VALID_VALUES_ARE + validValues);
        }

    }

    protected <E extends Enum<E>> void  validateFieldValue(Enum<E> value, String fieldName, Class<E> enumName) {
        if (Objects.isNull(value)) {
            addError(INVALID_ERROR_CODE, INVALID_ERROR_MESSAGE, fieldName, "Valid values are " + EnumUtils.getEnumList(enumName));
        }
    }

    protected void addError(String fieldName, String errorCode, String errorMessage) {
        errorDtoList.add(ErrorDto.builder().errorCode(errorCode).errorMessage(MessageFormat.format(errorMessage, fieldName)).build());
    }

    protected void addError(String errorCode, String errorMessage, Object... fieldNames) {
        errorDtoList.add(ErrorDto.builder().errorCode(errorCode).errorMessage(MessageFormat.format(errorMessage, fieldNames)).build());
    }

    protected void throwIfErrors() {
        if (CollectionUtils.isNotEmpty(errorDtoList)) {
            throw new ValidationException(errorDtoList);
        }
    }

    protected boolean validate(String value, String regex) {
        return !Pattern.matches(regex, value);
    }
}
@ControllerAdvice
public class KMSExceptionHandler {
    LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());

    @ExceptionHandler(value = {KeyManagementException.class})
    public ResponseEntity<Object> handleKMSException(KeyManagementException ex) {
        ErrorDto errorDto = ErrorDto.builder().errorCode(ex.getErrorCode()).errorMessage(ex.getErrorMessage()).build();
        return generateResponseWithErrors(List.of(errorDto));
    }

    @ExceptionHandler(value = {EncryptionDecryptionException.class})
    public ResponseEntity<Object> handleEncryptionDecryptionException(EncryptionDecryptionException ex) {
        ErrorDto errorDto = ErrorDto.builder().errorCode(ex.getErrorCode()).errorMessage(ex.getErrorMessage()).build();
        return generateResponseWithErrors(List.of(errorDto));
    }

    /**
     * Handle ValidationException
     *
     * @param ex ValidationException
     * @return ResponseEntity
     */
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<Object> handleValidationException(ValidationException ex) {
        logger.error("Handling ValidationException: {}", ex.getMessage(), ex);
        if (CollectionUtils.isEmpty(ex.getErrorMessages())) {
            ErrorDto errorDto = ErrorDto.builder().errorCode(ex.getErrorCode()).errorMessage(ex.getErrorMessage()).build();
            return generateResponseWithErrors(List.of(errorDto));
        }
        return generateResponseWithErrors(ex.getErrorMessages());
    }
    /**
     * Handle handleMethodArgumentTypeMismatch
     *
     * @param ex MethodArgumentTypeMismatchException
     * @return ResponseEntity
     */
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<Object> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        logger.error("Error in handleMethodArgumentTypeMismatch with message: {}", ex.getMessage());
        ErrorDto errorDto = ErrorDto.builder().errorCode(INVALID_ERROR_CODE)
                .errorMessage(MessageFormat.format(INVALID_ERROR_MESSAGE, ex.getPropertyName(), ex.getValue() + NOT_A_VALID_INPUT))
                .build();
        return generateResponseWithErrors(List.of(errorDto));
    }

    /**
     * Handle ResourceException
     *
     * @param ex NoResourceFoundException
     * @return ResponseEntity
     */
    @ExceptionHandler(NoResourceFoundException.class)
    public ResponseEntity<Object> handleResourceException(NoResourceFoundException ex) {
        logger.error("Error in handleResourceException for resource: {}, message: {}", ex.getResourcePath(), ex.getMessage());
        ErrorDto errorDto = ErrorDto.builder().errorCode(INVALID_ERROR_CODE)
                .errorMessage(MessageFormat.format(INVALID_ERROR_MESSAGE, ex.getResourcePath(), ex.getResourcePath() + NOT_A_VALID_URL)).build();
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(KMSResponse.builder().status(RESPONSE_FAILURE).errors(List.of(errorDto)).build());
    }

    @ExceptionHandler(value = {Exception.class})
    public ResponseEntity<Object> handleGenericException(Exception ex) {
        logger.error("Error in handleGenericException ", ex);
        ErrorDto errorDto = ErrorDto.builder().errorCode(UNCATEGORIZED_ERROR_CODE).errorMessage(UNCATEGORIZED_ERROR_MESSAGE).build();
        return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).body(KMSResponse.builder().status(RESPONSE_FAILURE).errors(List.of(errorDto)).build());
    }

    @ExceptionHandler(value = {MethodArgumentNotValidException.class})
    protected ResponseEntity<Object> handleValidationException(MethodArgumentNotValidException ex) {
        logger.error("Error in handleValidationException with message: {}", ex.getMessage());
        List<ErrorDto> errors = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(fieldError -> addErrorDto(errors, fieldError));
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(KMSResponse.builder().status(RESPONSE_FAILURE).errors(errors).build());
    }

    private void addErrorDto(List<ErrorDto> errors, FieldError fieldError) {
        String errCd = MANDATORY_ERROR_CODE;
        String errMsg = fieldError.getDefaultMessage();
        if(StringUtils.equalsIgnoreCase(MIN_VALUE_ERROR_MESSAGE, errMsg)) {
            errCd = MIN_VALUE_ERROR_CODE;
        }
        errors.add(ErrorDto.builder().errorCode(errCd)
                .errorMessage(MessageFormat.format(Objects.requireNonNull(errMsg), fieldError.getField())).build());
    }

    @ExceptionHandler(value = {IllegalArgumentException.class})
    protected ResponseEntity<Object> handleConflict(RuntimeException ex) {
        logger.error("Error in handleConflict ", ex);
        ErrorDto errorDto = ErrorDto.builder().errorCode(UNCATEGORIZED_ERROR_CODE).errorMessage(UNCATEGORIZED_ERROR_MESSAGE).build();
        return ResponseEntity.status(HttpStatus.CONFLICT).body(KMSResponse.builder().status(RESPONSE_FAILURE).errors(List.of(errorDto)).build());
    }

    private ResponseEntity<Object> generateResponseWithErrors(List<ErrorDto> errors) {
        return ResponseEntity.ok().body(KMSResponse.builder().status(RESPONSE_FAILURE).errors(errors).build());
    }

    /**
     * Handle EnumConversionException
     *
     * @param e MethodArgumentTypeMismatchException
     * @return ResponseEntity
     */
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<Object> handleEnumConversionException(HttpMessageNotReadableException e) {
        logger.error("Error in handleEnumConversionException with message: {}", e.getMessage());
        ErrorDto errorDto = ErrorDto.builder().errorCode(INVALID_ERROR_CODE).errorMessage(e.getMessage()).build();
        return generateResponseWithErrors(List.of(errorDto));
    }

    /**
     * Handle handleMethodArgumentTypeMismatch
     *
     * @param ex MethodArgumentTypeMismatchException
     * @return ResponseEntity
     */
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<Object> handleHttpRequestMethodNotSupportedException(HttpRequestMethodNotSupportedException ex) {
        logger.error("Error in handleHttpRequestMethodNotSupportedException for resource: {}",ex.getMessage());
        ErrorDto errorDto = ErrorDto.builder()
                .errorCode(String.valueOf(HttpStatus.METHOD_NOT_ALLOWED.value()))
                .errorMessage("Request method is not supported.")
                .build();
        return ResponseEntity.status(HttpStatus.OK).body(KMSResponse.builder().status(RESPONSE_FAILURE).errors(List.of(errorDto)).build());
    }

}
@Getter
public class ValidationException extends RuntimeException {

    private String errorCode;
    private String errorMessage;
    private List<ErrorDto> errorMessages;

    /**
     * Parametrized constructor taking errorcode and errorMessage
     *
     * @param errorCode    String
     * @param errorMessage String
     */
    public ValidationException(String errorCode, String errorMessage) {
        this.errorCode = errorCode;
        this.errorMessage = errorMessage;
    }

    /**
     * Parametrized constructor taking List of ErrorDTO
     *
     * @param errorMessages List
     */
    public ValidationException(List<ErrorDto> errorMessages) {
        this.errorMessages = errorMessages;
    }

}

here I'm not getting INVALID_FORMAT_OR_MAX_LEN_ERROR_MESSAGE insead of that getting UNCATEGORIZED_ERROR_MESSAGE
