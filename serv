package com.epay.merchant.dao;

import com.epay.merchant.dto.FooterDto;
import com.epay.merchant.dto.MerchantEntityGroupDto;
import com.epay.merchant.dto.MerchantUserDto;
import com.epay.merchant.dto.OnboardingDto;
import com.epay.merchant.entity.Footer;
import com.epay.merchant.entity.MerchantEntityGroup;
import com.epay.merchant.entity.MerchantInfo;
import com.epay.merchant.mapper.MerchantMapper;
import com.epay.merchant.model.request.FotterRequest;
import com.epay.merchant.model.request.OnboardingRequest;
import com.epay.merchant.repository.FooterRepository;
import com.epay.merchant.repository.MerchantEntityGroupRepository;
import com.epay.merchant.repository.MerchantRepository;
import com.epay.merchant.util.enums.MerchantStatus;
import com.epay.merchant.util.enums.UserStatus;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Class Name: AdminDao
 * Description: AdminDao is responsible for handling database operations related to the administration module of the system.
 * This includes CRUD operations for managing admin-related data, such as users, roles, and permissions.
 * It interacts directly with the database, using repositories or other data access technologies to persist and retrieve information.
 * <p>
 * Author: V1017903 (Bhushan Wadekar)
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * <p>
 * Version: 1.0
 */
@Component
@RequiredArgsConstructor
public class AdminDao {

    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    private final MerchantRepository merchantRepository;
    private final MerchantUserDao merchantUserDao;
    private final MerchantEntityGroupRepository merchantEntityGroupRepository;
    private final MerchantMapper mapper;
    private final FooterRepository footerRepository;

    @Transactional
    public OnboardingDto onboardingMerchantAndMerchantUser(OnboardingRequest onboardingRequest) {
        log.info("Onboarding request received");
        // Step 1 : Onboard Merchant
        MerchantInfo merchantInfo = mapper.mapMerchantDtoToEntity(onboardingRequest.getMerchant());
        merchantInfo.setStatus(MerchantStatus.ACTIVE.name());
        merchantInfo = merchantRepository.save(merchantInfo);
        // Step 2 : Onboard Merchant User
        MerchantUserDto merchantUserDto = merchantUserDao.saveMerchantUser(onboardingRequest.getUser(), merchantInfo.getMId());
        // Step 3 : Build Onboarding response
        return OnboardingDto.builder().merchant(mapper.mapMerchantInfoEntityToDto(merchantInfo)).user(merchantUserDto).build();
    }

    public boolean isMerchantExistByMId(String mId) {
        return merchantRepository.existsBymIdAndStatus(mId, MerchantStatus.ACTIVE.name());
    }

    public boolean isMerchantUserExist(String userName, String email, String mobilePhone) {
        return merchantUserDao.existsByUserNameOrEmailOrMobilePhoneAndStatus(userName, email, mobilePhone, UserStatus.ACTIVE);
    }

    public boolean isMerchantUserExistWithRoles(String userName, List<String> roles) {
        return merchantUserDao.existsByUserNameOrEmailOrMobilePhoneAndRoles(userName, roles);
    }
    public boolean isMerchantUserExistWithRoles(UUID userId, List<String> roles) {
        return merchantUserDao.existsByUserIdAndRoles(userId, roles);
    }

    public Page<MerchantUserDto> findAllMerchantUsersByMId(String mId, Pageable pageable) {
        return merchantUserDao.getAllMerchantUsersByMId(mId, pageable);
    }

    public List<String> findMappedEntityMIds(List<String> mIds) {
        return merchantEntityGroupRepository.findExistingMIds(mIds);
    }

    public List<String> findInvalidsMIds(List<String> mIds) {
        List<String> inActiveMIds = new ArrayList<>(mIds);
        List<String> activeMIds = merchantRepository.findActiveMIds(mIds);
        inActiveMIds.removeAll(activeMIds);
        return inActiveMIds;
    }


    public boolean isEntityIdPresent(String entityId) {
        return merchantEntityGroupRepository.existsByEntityId(entityId);
    }

    public MerchantEntityGroupDto saveMerchantEntityGroup(MerchantEntityGroupDto merchantEntityGroupDto) {
        List<MerchantEntityGroup> merchantEntityGroups = merchantEntityGroupDto.getMIds().stream().map(mId -> MerchantEntityGroup.builder().entityId(merchantEntityGroupDto.getEntityId()).mId(mId).build()).collect(Collectors.toList());
        merchantEntityGroupRepository.saveAll(merchantEntityGroups);
        return merchantEntityGroupDto;
    }
    public void updateUserRole(UUID userId, String userName, String entityId) {
        merchantUserDao.updateMerchantUserRole(userId, userName, entityId);
    }
    @Transactional
    public void saveFooterRequest(FotterRequest footerLabelRequest) {
        for (FooterDto footerLabelDto : footerLabelRequest.getFooterLabels()) {
            Footer footerResponse = footerRepository.findByLabel(footerLabelDto.getLabel().trim()).orElse(Footer.builder().label(footerLabelDto.getLabel().trim()).build());
            footerResponse.setValue(footerLabelDto.getValue());
            footerRepository.save(footerResponse);
        }
    }

}


I've to write test cases for this class and already I've written this test cases for this class which is giving me 26% coverage

import com.epay.merchant.dto.MerchantDto;
import com.epay.merchant.dto.MerchantUserDto;
import com.epay.merchant.dto.OnboardingDto;
import com.epay.merchant.entity.*;
import com.epay.merchant.mapper.MerchantMapper;
import com.epay.merchant.model.request.OnboardingRequest;
import com.epay.merchant.repository.*;
import com.epay.merchant.util.enums.MerchantStatus;
import com.epay.merchant.util.enums.MerchantUserRoles;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class AdminDaoTest {

    @Mock
    MerchantUserDao merchantUserDao;
    @InjectMocks
    private AdminDao adminDao;
    @Mock
    private MerchantRepository merchantRepo;
    @Mock
    private MerchantUserRepository merchantUserRepo;
    @Mock
    private MerchantUserRoleRepository userRoleRepo;
    @Mock
    private MerchantMapper merchantMapper;
    @Mock
    private DefaultUserPermissionRepository defaultUserPermissionRepo;
    @Mock
    private MenuInfoRepository menuInfoRepo;
    private OnboardingRequest onboardingRequest;

    private MerchantInfo merchantInfo;
    private MerchantUser merchantUser;
    private MerchantDto merchantDto;
    private MerchantUserDto merchantUserDto;
    private MerchantUserRole merchantUserRole;


    @BeforeEach
    void setUp() {
        onboardingRequest = OnboardingRequest.builder().merchant(MerchantDto.builder().city("vashi").build()).user(MerchantUserDto.builder().userName("username").build()).build();
        merchantInfo = MerchantInfo.builder().build();
        merchantUser = MerchantUser.builder().build();
        merchantDto = MerchantDto.builder().build();
        merchantUserDto = MerchantUserDto.builder().userName("user").build();
        merchantUserRole = MerchantUserRole.builder().build();

    }

    @Test
    public void onboardingTest() {

        MerchantInfo merchantInfo1 = MerchantInfo.builder().city("vashi").status(MerchantStatus.ACTIVE.name()).build();
        when(merchantMapper.mapMerchantDtoToEntity(onboardingRequest.getMerchant())).thenReturn(merchantInfo1);
        when(merchantMapper.mapMerchantUserDtoToEntity(any(MerchantUserDto.class))).thenReturn(merchantUser);
        when(merchantRepo.save(Mockito.any())).thenReturn(merchantInfo);
        when(merchantMapper.mapMerchantInfoEntityToDto(merchantInfo)).thenReturn(merchantDto);
        when(userRoleRepo.findByRole(MerchantUserRoles.ADMIN.name())).thenReturn(Optional.of(merchantUserRole));
        when(merchantUserRepo.save(Mockito.any())).thenReturn(merchantUserDto);
        when(merchantMapper.mapMerchantUserEntityToDto(merchantUser)).thenReturn(merchantUserDto);
        MenuInfo menu = new MenuInfo();
        menu.setId(UUID.randomUUID());
        when(menuInfoRepo.findAll()).thenReturn(List.of(menu));
        DefaultUserPermission defaultUserPermission = new DefaultUserPermission();
        defaultUserPermission.setMenuId(menu.getId());
        when(defaultUserPermissionRepo.findByRoleId(merchantUserRole.getId())).thenReturn(List.of(defaultUserPermission));
        when(merchantUserDao.saveMerchantUser(onboardingRequest.getUser(), merchantInfo.getMId())).thenReturn(merchantUserDto);

        OnboardingDto onboardingRequestRes = adminDao.onboardingMerchantAndMerchantUser(onboardingRequest);
        assertNotNull(onboardingRequestRes.getMerchant());
        assertEquals("user", onboardingRequestRes.getUser().getUserName());
    }

    @Test
    void testFindAllMerchantUsersByMId_ReturnsPageOfMerchantUsers() {
        String mid = "merchant123";
        Pageable pageable = PageRequest.of(0, 10);

        MerchantUserDto merchantUser = new MerchantUserDto();
        merchantUser.setFirstName("testUser");

        Page<MerchantUserDto> mockPage = new PageImpl<>(Collections.singletonList(MerchantUserDto.builder().firstName("testUser").build()));
        when(merchantUserDao.getAllMerchantUsersByMId(mid, pageable)).thenReturn(mockPage);
        Page<MerchantUserDto> result = adminDao.findAllMerchantUsersByMId(mid, pageable);

        assertEquals(1, result.getTotalElements());
        assertEquals("testUser", result.getContent().getFirst().getFirstName());
    }


    @Test
    void testFindAllMerchantUsersByMId_ReturnsEmptyPage() {
        String mid = "merchant123";
        Pageable pageable = PageRequest.of(0, 10);
        Page<MerchantUserDto> mockPage = Page.empty();
        when(merchantUserDao.getAllMerchantUsersByMId(mid, pageable)).thenReturn(mockPage);
        Page<MerchantUserDto> result = adminDao.findAllMerchantUsersByMId(mid, pageable);

        assertEquals(0, result.getTotalElements());
        assertEquals(0, result.getContent().size());
    }
}
