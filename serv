public MerchantResponse<String> changePassword(PasswordChangeRequest pwdChangeRequest) {
        try {
            log.info("Starting pwd change process for user: {}", pwdChangeRequest.getUserName());
            // Step 1: Validate mandatory pwd reset request
            passwordValidator.validateChangePassword(pwdChangeRequest);
            // Step 2 : Decrypt PWD
            pwdChangeRequest.setNewPassword(decryptValue(merchantConfig.getDecryptionKey(), pwdChangeRequest.getNewPassword()));
            pwdChangeRequest.setConfirmPassword(decryptValue(merchantConfig.getDecryptionKey(), pwdChangeRequest.getConfirmPassword()));
            log.info("PWD change request decrypted successfully");

            // Step 3: Validate the pwd change request
            validatePasswordChange(pwdChangeRequest);
            log.info("PWD change request validated successfully");

            // Step 4: Update the pwd details in the database. Added active for firstLogin true
            passwordManagementDao.updatePasswordDetails(pwdChangeRequest.getUserName(), pwdChangeRequest.getNewPassword(), List.of(UserStatus.ACTIVE,UserStatus.EXPIRED), RequestType.CHANGE_PASSWORD);

            // Step 5: Build and return the success response
            return MerchantResponse.<String>builder().status(RESPONSE_SUCCESS).data(List.of("Password Changed Successfully")).build();
        } catch (ValidationException e) {
            e.getErrorMessages().stream().filter(errorCode -> MANDATORY_ERROR_CODE.equals(errorCode.getErrorCode())).forEach(errorCode -> {
                throw e;
            });
            handlePasswordFailure(pwdChangeRequest.getUserName(), RequestType.CHANGE_PASSWORD, e.getErrorMessages().stream().map(ErrorDto::toString).collect(Collectors.joining(", ")));
            log.error("PWD Change Request Validation Failed for PasswordChangeRequest {} ", pwdChangeRequest);
            throw e;
        } catch (MerchantException e) {
            handlePasswordFailure(pwdChangeRequest.getUserName(), RequestType.CHANGE_PASSWORD, e.getErrorMessage());
            log.error("PWD Change Request Failed for PasswordChangeRequest {} ", pwdChangeRequest);
            throw e;
        } catch (Exception e) {
            handlePasswordFailure(pwdChangeRequest.getUserName(), RequestType.CHANGE_PASSWORD, e.getLocalizedMessage());
            log.error("PWD Change Request Failed for PasswordChangeRequest {} ", pwdChangeRequest);
            throw new MerchantException(GENERIC_ERROR_CODE, GENERIC_ERROR_MESSAGE);
        }
    }

in this class it's covering every method except 
this lines 
catch (ValidationException e) {
            e.getErrorMessages().stream().filter(errorCode -> MANDATORY_ERROR_CODE.equals(errorCode.getErrorCode())).forEach(errorCode -> {
                throw e;
            });
            handlePasswordFailure(pwdChangeRequest.getUserName(), RequestType.CHANGE_PASSWORD, e.getErrorMessages().stream().map(ErrorDto::toString).collect(Collectors.joining(", ")));
            log.error("PWD Change Request Validation Failed for PasswordChangeRequest {} ", pwdChangeRequest);
            throw e;
        }


    protected void handlePasswordFailure(String userName, RequestType requestType, String e) {
        log.info("Handling pwd failure for user: {}, RequestType: {}", userName, requestType);
        if (StringUtils.isNotEmpty(userName)) {
            try {
                passwordManagementDao.saveAudit(userName, requestType, false, e);
            } catch (MerchantException ex) {
                log.error("MerchantException in handlePasswordFailure for userName {}, RequestType {} ", userName, requestType, ex.getErrorMessage());
            } catch (Exception ex) {
                log.error("Generic Error in handlePasswordFailure for userName {}, RequestType {} ", userName, requestType, ex.getMessage());
            }
        }
    }
this lines can you please add test case for this I already have a test class for this
@ExtendWith(MockitoExtension.class)
class PasswordServiceTest {

    @Mock
    private PasswordValidator passwordValidator;

    @Mock
    private PasswordManagementDao passwordManagementDao;

    @Mock
    private MerchantConfig merchantConfig;

    @InjectMocks
    private PasswordService passwordService;

    private static final String DUMMY_KEY = "dummyDecryptionKey";

    @BeforeEach
    void setUp() {
        lenient().when(merchantConfig.getDecryptionKey()).thenReturn(DUMMY_KEY);
    }

    @Test
    void testChangePasswordSuccess() {
        PasswordChangeRequest request = new PasswordChangeRequest();
        request.setUserName("testUser");
        request.setOldPassword("encryptedOldPwd");
        request.setNewPassword("encryptedNewPwd");
        request.setConfirmPassword("encryptedNewPwd");

        MerchantUserDto dummyUser = new MerchantUserDto();
        dummyUser.setStatus(UserStatus.ACTIVE);
        dummyUser.setFirstLogin(false);

        when(passwordManagementDao.findByUserNameOrEmailOrMobilePhoneAndStatus(eq("testUser"), anyList()))
                .thenReturn(dummyUser);

        doNothing().when(passwordValidator).validatePasswordUpdateWithDB(any(MerchantUserDto.class), anyString(), anyString());

        doNothing().when(passwordManagementDao).updatePasswordDetails(
                eq("testUser"),
                eq("decryptedNewPwd"),
                anyList(),
                eq(RequestType.CHANGE_PASSWORD)
        );
        try (MockedStatic<EncryptionDecryptionUtil> cryptoUtil = mockStatic(EncryptionDecryptionUtil.class)) {
            cryptoUtil.when(() ->
                    EncryptionDecryptionUtil.decryptValue(eq(DUMMY_KEY), eq("encryptedNewPwd"))
            ).thenReturn("decryptedNewPwd");
            cryptoUtil.when(() ->
                    EncryptionDecryptionUtil.decryptValue(eq(DUMMY_KEY), eq("encryptedOldPwd"))
            ).thenReturn("decryptedOldPwd");
            cryptoUtil.when(() ->
                    EncryptionDecryptionUtil.hashValue(eq("decryptedNewPwd"))
            ).thenReturn("hashedNewPwd");

            MerchantResponse<String> response = passwordService.changePassword(request);

            assertNotNull(response);
            assertEquals(RESPONSE_SUCCESS, response.getStatus());
            assertTrue(response.getData().contains("Password Changed Successfully"));

        }
    }

    @Test
    void testChangePasswordValidationException() {
        PasswordChangeRequest request = new PasswordChangeRequest();
        request.setUserName("testUser");
        request.setOldPassword("encryptedOldPwd");
        request.setNewPassword("encryptedNewPwd");
        request.setConfirmPassword("encryptedNewPwd");

        MerchantException thrown = assertThrows(MerchantException.class, () -> passwordService.changePassword(request));
        assertEquals(GENERIC_ERROR_CODE, thrown.getErrorCode());
    }

    @Test
    void testChangePasswordMerchantException() {
        PasswordChangeRequest request = new PasswordChangeRequest();
        request.setUserName("testUser");
        request.setOldPassword("encryptedOldPwd");
        request.setNewPassword("encryptedNewPwd");
        request.setConfirmPassword("encryptedNewPwd");

        try (MockedStatic<EncryptionDecryptionUtil> cryptoUtil = mockStatic(EncryptionDecryptionUtil.class)) {
            cryptoUtil.when(() ->
                    EncryptionDecryptionUtil.decryptValue(eq(DUMMY_KEY), eq("encryptedNewPwd"))
            ).thenReturn("decryptedNewPwd");
            cryptoUtil.when(() ->
                    EncryptionDecryptionUtil.decryptValue(eq(DUMMY_KEY), eq("encryptedOldPwd"))
            ).thenReturn("decryptedOldPwd");
            cryptoUtil.when(() ->
                    EncryptionDecryptionUtil.hashValue(eq("decryptedNewPwd"))
            ).thenReturn("hashedNewPwd");

            doNothing().when(passwordValidator).validatePasswordValue(anyString(), anyString());

            when(passwordManagementDao.findByUserNameOrEmailOrMobilePhoneAndStatus(eq("testUser"), anyList()))
                    .thenThrow(new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE, "Merchant error occurred"));

            MerchantException thrown = assertThrows(MerchantException.class, () -> passwordService.changePassword(request));
            assertEquals("Merchant error occurred", thrown.getErrorMessage());
        }
    }

    @Test
    void testChangePasswordGenericException() {
        PasswordChangeRequest request = new PasswordChangeRequest();
        request.setUserName("testUser");
        request.setOldPassword("encryptedOldPwd");
        request.setNewPassword("encryptedNewPwd");
        request.setConfirmPassword("encryptedNewPwd");

        try (MockedStatic<EncryptionDecryptionUtil> cryptoUtil = mockStatic(EncryptionDecryptionUtil.class)) {
            cryptoUtil.when(() ->
                    EncryptionDecryptionUtil.decryptValue(eq(DUMMY_KEY), eq("encryptedNewPwd"))
            ).thenThrow(new RuntimeException("Decryption failed"));

            MerchantException thrown = assertThrows(MerchantException.class, () -> passwordService.changePassword(request));
            assertEquals(ErrorConstants.GENERIC_ERROR_MESSAGE, thrown.getErrorMessage());
        }
    }

    @Test
    void testResetPasswordSuccess() {

        PasswordResetRequest request = new PasswordResetRequest();
        request.setUserName("testUser");
        request.setNewPassword("encryptedNewPwd");
        request.setConfirmPassword("encryptedNewPwd");

        doNothing().when(passwordValidator).validatePasswordValue(anyString(), anyString());

        MerchantUserDto dummyUser = new MerchantUserDto();
        dummyUser.setStatus(UserStatus.ACTIVE);
        dummyUser.setFirstLogin(false);

        when(passwordManagementDao.findByUserNameOrEmailOrMobilePhoneAndStatus(eq("testUser"), anyList()))
                .thenReturn(dummyUser);

        doNothing().when(passwordValidator).validatePasswordUpdateWithDB(any(MerchantUserDto.class), anyString());

        doNothing().when(passwordManagementDao).updatePasswordDetails(
                eq("testUser"),
                eq("decryptedNewPwd"),
                anyList(),
                eq(RequestType.RESET_PASSWORD)
        );

        // Use static mocking for EncryptionDecryptionUtil.
        try (MockedStatic<EncryptionDecryptionUtil> cryptoUtil = mockStatic(EncryptionDecryptionUtil.class)) {
            cryptoUtil.when(() ->
                    EncryptionDecryptionUtil.decryptValue(eq(DUMMY_KEY), eq("encryptedNewPwd"))
            ).thenReturn("decryptedNewPwd");
            cryptoUtil.when(() ->
                    EncryptionDecryptionUtil.hashValue(eq("decryptedNewPwd"))
            ).thenReturn("hashedNewPwd");

            // Act: Call the resetPassword method.
            MerchantResponse<String> response = passwordService.resetPassword(request);

            // Assert: Validate the success response.
            assertNotNull(response);
            assertEquals(RESPONSE_SUCCESS, response.getStatus());
            assertTrue(response.getData().contains(MerchantConstant.PWD_RESET_SUCCESSFULLY));
        }
    }

    @Test
    void testResetPasswordValidationException() {
        // Arrange: Create a PasswordResetRequest.
        PasswordResetRequest request = new PasswordResetRequest();
        request.setUserName("testUser");
        request.setNewPassword("encryptedNewPwd");
        request.setConfirmPassword("encryptedNewPwd");

        // Act & Assert: Expect a ValidationException.
        MerchantException thrown = assertThrows(MerchantException.class, () -> passwordService.resetPassword(request));
        assertEquals(GENERIC_ERROR_CODE, thrown.getErrorCode());
    }

    @Test
    void testResetPasswordMerchantException() {
        // Arrange: Create a request.
        PasswordResetRequest request = new PasswordResetRequest();
        request.setUserName("testUser");
        request.setNewPassword("encryptedNewPwd");
        request.setConfirmPassword("encryptedNewPwd");
        try (MockedStatic<EncryptionDecryptionUtil> cryptoUtil = mockStatic(EncryptionDecryptionUtil.class)) {
            cryptoUtil.when(() ->
                    EncryptionDecryptionUtil.decryptValue(eq(DUMMY_KEY), eq("encryptedNewPwd"))
            ).thenReturn("decryptedNewPwd");
            cryptoUtil.when(() ->
                    EncryptionDecryptionUtil.hashValue(eq("decryptedNewPwd"))
            ).thenReturn("hashedNewPwd");

            doNothing().when(passwordValidator).validatePasswordValue(anyString(), anyString());

            // Simulate MerchantException from DAO.
            when(passwordManagementDao.findByUserNameOrEmailOrMobilePhoneAndStatus(eq("testUser"), anyList()))
                    .thenThrow(new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE, "Merchant error occurred"));

            MerchantException thrown = assertThrows(MerchantException.class, () -> passwordService.resetPassword(request));
            assertEquals("Merchant error occurred", thrown.getErrorMessage());
        }
    }

    @Test
    void testResetPasswordGenericException() {
        // Arrange: Create a request.
        PasswordResetRequest request = new PasswordResetRequest();
        request.setUserName("testUser");
        request.setNewPassword("encryptedNewPwd");
        request.setConfirmPassword("encryptedNewPwd");

        // Force decryption failure.
        try (MockedStatic<EncryptionDecryptionUtil> cryptoUtil = mockStatic(EncryptionDecryptionUtil.class)) {
            cryptoUtil.when(() ->
                    EncryptionDecryptionUtil.decryptValue(eq(DUMMY_KEY), eq("encryptedNewPwd"))
            ).thenThrow(new RuntimeException("Decryption failed"));

            MerchantException thrown = assertThrows(MerchantException.class, () -> passwordService.resetPassword(request));
            assertEquals(GENERIC_ERROR_CODE, thrown.getErrorCode());
        }
    }

    @Test
    void testProcessUsersWithExpiredPassword() {
        passwordService.processUsersWithExpiredPassword();
    }

}
