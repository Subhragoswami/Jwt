    private void buildReport(UUID reportManagementId, ReportManagementDto reportManagementDto, List<String> header, List<List<Object>> fileData) {
        log.info("Building report for ReportManagementId: {} and format: {}", reportManagementId, reportManagementDto.getFormat());
        FileModel fileModel = fileGeneratorService.buildFileModel(reportManagementDto.getFormat(), header, fileData, Map.of("headers", header, "rows", fileData));
        log.info("File model created, generating file for report.");
        ReportFile reportFile = fileGeneratorService.generateFile(reportManagementDto.getFormat(), reportManagementDto.getReport(), reportManagementDto.getMId(), fileModel);
        String s3FileName = s3Service.uploadFile(reportFile.getName(), reportFile.getContent());
        reportManagementDao.updateStatusAndFilePath(reportManagementId, ReportStatus.GENERATED, s3FileName);
        publishReportGenerationAlert(reportManagementDto);
        log.info("Report generated and file path [{}] updated for ReportManagementId: {}", s3FileName, reportManagementId);
    }

here i need to implement if fileData is more than 10000 then need to create zip file 

here we're implementing generateZipFile in other service method like this
public ReportingResponse<String> generateMerchantFeesInvoice(String mId, List<String> reportMonths, HttpServletResponse response) {
        try {
            log.info("Received Fees invoice generation for mId {}, reportMonths {}", mId, reportMonths);
            invoiceValidator.validateRequestMonths(reportMonths);
            mIdValidator.validateActiveMId(mId);
            List<Map<String, Object>> feesInvoiceData = invoiceDao.getFeesInvoiceData(mId, reportMonths);
            if(CollectionUtils.isNotEmpty(feesInvoiceData)) {
                if (feesInvoiceData.size() > 1) {
                    List<FileModel> fileModels = getFileModels(feesInvoiceData);
                    fileGeneratorService.generateZipFile(response, ReportFormat.PDF, Report.FEES_INVOICE, mId, fileModels);
                } else {
                    FileModel fileModel = PdfFileModel.builder().fileData(feesInvoiceData.getFirst()).build();
                    fileGeneratorService.downloadFile(response, ReportFormat.PDF, Report.FEES_INVOICE, mId, fileModel);
                }
                return ReportingResponse.<String>builder().status(ReportingConstant.RESPONSE_SUCCESS).build();
            }
            throw new ReportingException(NOT_FOUND_ERROR_CODE, MessageFormat.format(NOT_FOUND_ERROR_MESSAGE, DATA));
        } catch (ValidationException e){
            log.error("Failed to generate PDF for MID {} and Report: {} during Validation. Error : {}", mId, reportMonths, e.getErrorMessages());
            throw e;
        } catch (ReportingException e){
            log.error("Failed to generate PDF for MID {} and Report: {}, at file generation. Error : {}", mId, reportMonths, e.getErrorMessages());
            throw e;
        } catch (Exception e) {
            log.error("Failed to generate PDF for MID {} and Report: {}. Error : {}", mId, reportMonths, e.getMessage());
            throw new ReportingException(ErrorConstants.GENERATION_ERROR_CODE, MessageFormat.format(ErrorConstants.GENERATION_ERROR_MESSAGE, reportMonths));
        }
    }

public void generateZipFile(HttpServletResponse response, ReportFormat reportFormat, Report report, String mId, List<FileModel> fileModels) {
        log.info("Started zipFileGenerator for reportFormat: {}, report: {}, mId: {}, fileModels: {}", reportFormat, report.getName(),mId,fileModels);
        zipFileGenerator.generateZipFile(response, reportFormat, report, mId, fileModels);
    }

public void generateZipFile(HttpServletResponse response, ReportFormat reportFormat, Report report, String mId, List<FileModel> fileModels) {
        log.info("Starting ZIP file generation for report: {} and merchant ID: {}", report.getName(), mId);
        try {
            ByteArrayOutputStream byteArrayOutputStream;
            if(fileModels.size()> 1) {
               byteArrayOutputStream = generateZipFile(reportFormat, report, mId, fileModels);
            }else {
                byteArrayOutputStream = generateConsolidatedZipFile(reportFormat, report, mId, fileModels);
            }
            setHeader(response, "application/zip", format("%s_%s_%s.zip", mId, report.getName(), System.currentTimeMillis()));
            response.setContentLength(byteArrayOutputStream.size());
            response.getOutputStream().write(byteArrayOutputStream.toByteArray());
            response.getOutputStream().flush();
            log.info("ZIP file successfully generated and sent to the response.");
        } catch (Exception e) {
            log.error("Error occurred during zipFileGenerator : {}", e.getMessage());
            throw new ReportingException(ErrorConstants.FILE_GENERATION_ERROR_CODE, MessageFormat.format(ErrorConstants.FILE_GENERATION_ERROR_MESSAGE, "zip", e.getMessage()));
        }

    private ByteArrayOutputStream generateZipFile(ReportFormat reportFormat, Report report, String mId, List<FileModel> fileModels) throws IOException {
        log.info("Generating ZIP file for report: {} with format: {}", report.getName(), reportFormat.name());
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ZipOutputStream zos = new ZipOutputStream(byteArrayOutputStream);
            for (FileModel fileModel : fileModels) {
                ReportFile reportFile = fileGenerator.generateFile(reportFormat, report, mId, fileModel);
                ZipEntry zipEntry = new ZipEntry(getZipFileName(reportFormat, report, fileModel));
                zos.putNextEntry(zipEntry);
                byte[] content = reportFile.getContent();
                if (content != null && content.length > 0) {
                    zos.write(content);
                } else {
                    log.info("Skipping empty file: {}", zipEntry.getName());
                }
                zos.closeEntry();
            }
            zos.finish();

        log.info("ZIP file generation completed for report: {}", report.getName());
        return byteArrayOutputStream;
    }

    public ReportFile generateFile(ReportFormat reportFormat, Report report, String mId, FileModel fileModel) {
        logger.info("Generating file for report format: {}, report: {}, mId: {}", reportFormat, report.getName(), mId);
        switch (reportFormat) {
            case CSV -> {
                CSVFileModel csvFileModel = (CSVFileModel) fileModel;
                return CSVGenerator.csvFileGenerator(report.getName(), mId, csvFileModel.getHeaders(), csvFileModel.getFileData());
            }
            case XLS -> {
                ExcelFileModel xlsFileModel = (ExcelFileModel) fileModel;
                return ExcelGenerator.excelFileGenerator(report.getName(), mId, xlsFileModel.getHeaders(), xlsFileModel.getFileData());
            }
            case PDF -> {
                PdfFileModel pdfFileModel = (PdfFileModel) fileModel;
                return pdfGenerator.pdfFileGenerator(report.getName(), mId, report.getTemplateName(), pdfFileModel.getFileData());
            }
            default -> {
                logger.error("Unsupported report format: {}", reportFormat);
                throw new IllegalArgumentException("Requested File Formatter not supported");
            }
        }
    }
