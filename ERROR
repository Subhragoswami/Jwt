package com.epay.merchant.dao;

import com.epay.merchant.config.MerchantConfig;
import com.epay.merchant.dto.MerchantEmailDto;
import com.epay.merchant.dto.MerchantUserDto;
import com.epay.merchant.dto.MerchantUserRoleDto;
import com.epay.merchant.dto.SmsRequest;
import com.epay.merchant.entity.*;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.mapper.MerchantMapper;
import com.epay.merchant.model.request.MerchantUserGetRequest;
import com.epay.merchant.model.request.MerchantUserUpdateRequest;
import com.epay.merchant.model.response.MerchantUserResponse;
import com.epay.merchant.model.response.UserMenuPermissionEntityDetails;
import com.epay.merchant.model.response.UserProfileResponse;
import com.epay.merchant.model.response.UserRoleResponse;
import com.epay.merchant.repository.*;
import com.epay.merchant.specification.MerchantUserSpecification;
import com.epay.merchant.util.*;
import com.epay.merchant.util.enums.EMailType;
import com.epay.merchant.util.enums.MerchantUserRoles;
import com.epay.merchant.util.enums.NotificationEntityType;
import com.epay.merchant.util.enums.UserStatus;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import jakarta.transaction.Transactional;
import jakarta.validation.constraints.NotNull;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.ObjectUtils;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Component;

import java.text.MessageFormat;
import java.util.*;
import java.util.stream.Collectors;

import static org.apache.commons.collections4.CollectionUtils.isNotEmpty;

/**
 * Class Name: MerchantUserDao
 * *
 * Description:
 * *
 * Author: Vikram Deshpande
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
@Component
@RequiredArgsConstructor
public class MerchantUserDao {

    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    private final MerchantUserRepository merchantUserRepository;
    private final UserMenuPermissionRepository userMenuPermissionRepository;
    private final DefaultUserPermissionRepository defaultUserPermissionRepository;
    private final MenuInfoRepository menuInfoRepository;
    private final MerchantEntityUserRepository merchantEntityUserRepository;

    private final MerchantUserRoleDao merchantUserRoleDao;
    private final NotificationDao notificationDao;

    private final MerchantMapper merchantMapper;
    private final MerchantConfig merchantConfig;
    private final PasswordGenerator passwordGenerator;

    private static NotificationManagement buildNotificationManagement(UUID userId) {
        return NotificationManagement.builder().requestType("UserCreation").entityId(userId).entityName(NotificationEntityType.MERCHANT_USER).build();
    }

    public MerchantUserDto getByUserNameOrEmailOrMobilePhoneAndStatus(String userName, String email, String phone, List<UserStatus> userStatus) {
        MerchantUser merchantUser = getMerchantUserByStatus(userName, email, phone, userStatus);
        return merchantMapper.mapMerchantUserEntityToDto(merchantUser);
    }

    public MerchantUserDto getByUserName(String userName, UserStatus userStatus) {
        MerchantUser merchantUser = getMerchantUserByStatus(userName, userName, userName, List.of(userStatus));
        return merchantMapper.mapMerchantUserEntityToDto(merchantUser);
    }

    public boolean isMerchantUserExistByUserNameAndPassword(String userName, String password) {
        return merchantUserRepository.isMerchantUserExistsByUserNameOrEmailOrMobilePhoneAndPassword(userName, password);
    }

    public UserProfileResponse getMerchantUserProfile(String userName, UserStatus userStatus) {
        MerchantUser merchantUser = getMerchantUserByStatus(userName, userName, userName, List.of(userStatus));
        UserProfileResponse userProfileResponse = merchantMapper.mapMerchantUserEntityToProfileResponse(merchantUser);
        userProfileResponse.setRoleName(merchantUserRepository.findUserRoleByUserId(merchantUser.getId()));
        return userProfileResponse;
    }

    public List<UserMenuPermissionEntityDetails> getUserMenuPermission(UUID userId) {
        return userMenuPermissionRepository.findUserMenuPermissionByUserId(userId);
    }

    public MerchantUser save(MerchantUser merchantUser) {
        return merchantUserRepository.save(merchantUser);
    }

    public boolean existsByUserNameOrEmailOrMobilePhoneAndStatus(String userName, String email, String phone, UserStatus userStatus) {
        return merchantUserRepository.existsByUserNameOrEmailOrMobilePhoneAndStatus(userName, email, phone, userStatus);
    }

    public List<String> getUserNameByEmailOrMobilePhoneAndStatus(String email, String phone, UserStatus userStatus) {
        return merchantUserRepository.getUserNameByEmailOrMobilePhoneAndStatus(email, phone, userStatus);
    }

    public boolean existsByUserNameOrEmailOrMobilePhoneAndRoles(String userName, List<String> roles) {
        return merchantUserRepository.existsByUserNameOrEmailOrMobilePhoneAndRoles(userName, roles);
    }

    public boolean existsByUserIdAndRoles(UUID userId, List<String> roles) {
        return merchantUserRepository.existsByUserIdAndRoles(userId, roles);
    }

    public MerchantUserDto updateMerchantUserForPassword(String userName, String password, List<UserStatus> userStatus) {
        MerchantUser merchantUser = getMerchantUserByStatus(userName, userName, userName, userStatus);
        merchantUser.setPassword(password);
        merchantUser.setLastPasswordChange(DateTimeUtils.getCurrentTimeInMills());
        merchantUser.setPasswordExpiryTime(DateTimeUtils.getFutureDateByMonth(merchantConfig.getPasswordExpiryMonths()));
        merchantUser.setStatus(UserStatus.ACTIVE);
        merchantUser = save(merchantUser);
        return merchantMapper.mapMerchantUserEntityToDto(merchantUser);
    }

    public boolean isUserHaveAccessToMId(String userName, List<String> mIds) {
        boolean isAccessable = merchantUserRepository.isUserHaveAccessOfMerchant(mIds, userName);
        if (!isAccessable) {
            isAccessable = merchantUserRepository.isUserHaveAccessOfEntityMerchant(mIds, userName);
        }
        return isAccessable;
    }

    @Transactional
    public MerchantUserDto saveMerchantUser(MerchantUserDto merchantUserDto, String... mIds) {
        //Step 1 : Password Generator
        String password = passwordGenerator.generatePassword();

        //Step 2 : Set Up Default Value
        setMerchantUserDefaultValues(merchantUserDto, password);

        //Step 3 : Save Merchant User
        MerchantUser merchantUser = merchantMapper.mapMerchantUserDtoToEntity(merchantUserDto);
        merchantUser = merchantUserRepository.save(merchantUser);

        //Step 4 : Assigned MIDs to Merchant User
        if (ArrayUtils.isNotEmpty(mIds)) {
            assignMerchantToUser(merchantUser.getId(), mIds);
        }

        //Step 5 : Assigned Default Menu permission to Merchant User
        createMerchantUserMenuPermissions(merchantUser.getId(), merchantUser.getRole());

        //Step 5 : Send Notification
        sendNotification(merchantUser, password);

        return merchantMapper.mapMerchantUserEntityToDto(merchantUser);
    }

    public MerchantUserResponse updateUserStatusByUserName(String userName, MerchantUserUpdateRequest merchantUserUpdateRequest) {
        MerchantUser merchantUser = merchantUserRepository.findByUserNameOrEmailOrMobilePhone(userName, userName, userName).orElseThrow(() -> new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "User Name")));
        merchantUser.setStatus(merchantUserUpdateRequest.getStatus());
       // merchantUser.setRemark(merchantUserUpdateRequest.getRemark());
        return merchantMapper.mapMerchantUserEntityToResponse(merchantUserRepository.save(merchantUser));
    }

    public boolean isMerchantUserExist(String userName) {
        return merchantUserRepository.existsByUserNameOrEmailOrMobilePhone(userName, userName, userName);
    }

    public Page<MerchantUserDto> getAllMerchantUsersByMId(String mId, Pageable pageable) {
        return merchantUserRepository.findBymId(mId, pageable).map(this::convertEntityToDTO);
    }

    public MerchantUserDto updateMerchantUser(MerchantUserDto merchantUserDto, boolean isProfileUpdate) {
        //Step 1 : Map DTO with Entity and Set DB ID
        MerchantUser merchantUser = merchantMapper.mapMerchantUserDtoToEntity(merchantUserDto);
        setMerchantUserId(merchantUser, isProfileUpdate);

        //Step 2 : Save Merchant User
        merchantUser = merchantUserRepository.save(merchantUser);

        return merchantMapper.mapMerchantUserEntityToDto(merchantUser);
    }

    public String getUserRoleName(UUID roleId) {
        return merchantUserRoleDao.getRoleNameById(roleId).getRole();
    }

    public List<UserRoleResponse> getUserRoles() {
        return merchantUserRoleDao.getAllUserRole();
    }

    public int updateMerchantUserForLogin(MerchantUserDto merchantUserDto, boolean loginStatus) {
        MerchantUser merchantUser = merchantMapper.mapMerchantUserDtoToEntity(merchantUserDto);
        if (loginStatus) {
            merchantUser.setLastSuccessLogin(System.currentTimeMillis());
            merchantUser.setLoginFailAttempt(0);
        } else {
            merchantUser.setLastFailLogin(System.currentTimeMillis());
            merchantUser.setLoginFailAttempt(merchantUser.getLoginFailAttempt() + 1);
        }
        if (merchantUser.getLoginFailAttempt() > merchantConfig.getAllowedLoginFailAttempt() && !UserStatus.BLOCKED.equals(merchantUser.getStatus())) {
            merchantUser.setStatus(UserStatus.BLOCKED);
        }
        merchantUserRepository.save(merchantUser);
        return merchantUser.getLoginFailAttempt();
    }

    public void updateMerchantUserRole(UUID userId, String userName, String entityId) {
        // Step 1 : Find Merchant User
        MerchantUser merchantUser = retrieveUser(userId, userName);
        // Step 2 : Role Alignment
        Map<UUID, MerchantUserRoleDto> roleMap = merchantUserRoleDao.getUserRoleDtoMap();
        MerchantUserRoleDto userRole = roleMap.get(merchantUser.getRole());
        if (MerchantUserRoles.SUPER_ADMIN.name().equals(userRole.getRole())) {
            // Step 3 : Super Admin Role Alignment
            log.info("User is a SUPER_ADMIN. Updating entityId for userId: {}", merchantUser.getId());
            merchantEntityUserRepository.updateEntityIdForUser(merchantUser.getId(), entityId);
        } else if (MerchantUserRoles.ADMIN.name().equals(userRole.getRole())) {
            // Step 3 : Move User to Admin to Super Admin Role
            log.info("User is an ADMIN. Upgrading role and saving entityId for userId: {}", merchantUser.getId());
            assignedMerchantUserToSuperAdminRole(merchantUser, entityId);
        }
    }

    public Page<MerchantUserDto> findMerchantUsers(MerchantUserGetRequest merchantUserGetRequest) {
        Pageable pageable = PageRequest.of(merchantUserGetRequest.getPage(), merchantUserGetRequest.getSize());
        Specification<MerchantUser> specification = MerchantUserSpecification.searchUsers(merchantUserGetRequest.getUserName(), merchantUserGetRequest.getName(), merchantUserGetRequest.getMobilePhone(), merchantUserGetRequest.getFromDate(), merchantUserGetRequest.getToDate(), merchantUserGetRequest.getStatus());
        return merchantUserRepository.findAll(specification, pageable).map(this::convertEntityToDTO);
    }

    @Transactional
    public void assignedMIds(List<String> newMappedMIds, List<String> removedMIds, UUID userId) {
        if (isNotEmpty(removedMIds)) {
            merchantEntityUserRepository.deleteByUserIdAndMIds(userId, removedMIds);
        }
        if (isNotEmpty(newMappedMIds)) {
            assignMerchantToUser(userId, newMappedMIds.toArray(new String[0]));
        }
    }

    private MerchantUser retrieveUser(UUID userId, String userName) {
        Optional<MerchantUser> merchantUser = ObjectUtils.isNotEmpty(userId) ? merchantUserRepository.findById(userId) : merchantUserRepository.findByUserNameOrEmailOrMobilePhoneAndStatusIn(userName, userName, userName, List.of(UserStatus.ACTIVE));
        return merchantUser.orElseThrow(() -> new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "Valid User")));
    }

    @Transactional
    private void assignedMerchantUserToSuperAdminRole(@NotNull MerchantUser merchantUser, String entityId) {
        //Step 1 : Update User Role to Super Admin
        UUID superAdminRoleId = merchantUserRoleDao.getSuperAdminRoleId();
        merchantUser.setRole(superAdminRoleId);
        merchantUser = merchantUserRepository.save(merchantUser);
        //Step 2 : Remove assigned MIds
        merchantEntityUserRepository.deleteByUserId(merchantUser.getId());
        //Step 3 : Assigned Entity Ids to user
        MerchantEntityUser newEntityUser = MerchantEntityUser.builder().userId(merchantUser.getId()).entityId(entityId).build();
        merchantEntityUserRepository.save(newEntityUser);
        //Step 4 : Update the menu permission as Super Admin
        updateUserMenuPermission(merchantUser.getId(), superAdminRoleId);
    }

    private void updateUserMenuPermission(UUID userId, UUID roleId) {
        if (!ObjectUtils.isEmpty(userMenuPermissionRepository.findByUserId(userId))) {
            userMenuPermissionRepository.deleteByUserId(userId);
        }
        createMerchantUserMenuPermissions(userId, roleId);
    }

    /**
     * Sending onboarding email and/or SMS.
     */
    private void sendNotification(MerchantUser merchantUser, String password) {
        NotificationManagement notificationMgmt = buildNotificationManagement(merchantUser.getId());
        sendEmail(merchantUser, notificationMgmt);
        sendSms(merchantUser, notificationMgmt);
        sendPasswordEmail(merchantUser, password, notificationMgmt);
    }

    private void sendEmail(MerchantUser merchantUser, NotificationManagement notificationMgmt) {
        MerchantEmailDto merchantEmailDto = MerchantEmailDto.builder().toEmail(merchantUser.getEmail()).content(EmailUtil.generateUserCreationContent(merchantUser)).eMailType(EMailType.USER_CREATION).build();
        notificationDao.sendEmailNotification(merchantEmailDto, notificationMgmt);
    }

    private void sendSms(MerchantUser merchantUser, NotificationManagement notificationMgmt) {
        SmsRequest smsRequest = SmsRequest.builder().mobileNumber(merchantUser.getMobilePhone()).message(MessageFormat.format(SmsUtil.USER_ONBOARDING, merchantUser.getUserName())).build();
        notificationDao.sendSmsNotification(smsRequest, notificationMgmt);
    }

    private void sendPasswordEmail(MerchantUser merchantUser, String password, NotificationManagement notificationMgmt) {
        MerchantEmailDto merchantEmailDto = MerchantEmailDto.builder().toEmail(merchantUser.getEmail()).content(EmailUtil.generateDefaultContent("Password has been generated successfully,Password is " + password)).eMailType(EMailType.PASSWORD_GENERATION).build();
        notificationDao.sendEmailNotification(merchantEmailDto, notificationMgmt);
    }

    private void assignMerchantToUser(UUID userId, String... mIds) {
        List<MerchantEntityUser> merchantEntityUsers = Arrays.stream(mIds).map(mId -> MerchantEntityUser.builder().userId(userId).mId(mId).build()).collect(Collectors.toList());
        merchantEntityUserRepository.saveAll(merchantEntityUsers);
    }

    private MerchantUser getMerchantUserByStatus(String userName, String email, String phone, List<UserStatus> userStatus) {
        return merchantUserRepository.findByUserNameOrEmailOrMobilePhoneAndStatusIn(userName, email, phone, userStatus).orElseThrow(() -> new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, userStatus.toString() + " Merchant User")));
    }

    private MerchantUserDto convertEntityToDTO(MerchantUser merchantUser) {
        return merchantMapper.mapMerchantUserEntityToDto(merchantUser);
    }

    /**
     * Creating Merchant User Permission for Admin User
     *
     * @param userId UUID
     */
    private void createMerchantUserMenuPermissions(final UUID userId, final UUID roleId) {
        List<DefaultUserPermission> defaultUserPermissions = defaultUserPermissionRepository.findByRoleId(roleId);
        List<MenuInfo> menuInfos = menuInfoRepository.findAll();
        List<UserMenuPermission> userMenuPermissions = new ArrayList<>();
        if (isNotEmpty(menuInfos)) {
            menuInfos.forEach(menuInfo -> defaultUserPermissions.stream().filter(defaultUserPermission -> defaultUserPermission.getMenuId().equals(menuInfo.getId())).findFirst().ifPresent(defaultUserPermission -> userMenuPermissions.add(UserMenuPermission.builder().permissionId(defaultUserPermission.getPermissionId()).userId(userId).menuId(menuInfo.getId()).build())));
            userMenuPermissionRepository.saveAll(userMenuPermissions);
        }
    }

    /**
     * Setting default values if it is not present in onboarding request.
     *
     * @param user MerchantUserDto
     */
    private void setMerchantUserDefaultValues(MerchantUserDto user, String password) {
        String userName = EPayIdentityUtil.getUserPrincipal().getUsername();
        MerchantUser merchantUser = getMerchantUserByStatus(userName, userName, userName, List.of(UserStatus.ACTIVE));
        if (ObjectUtils.isEmpty(user.getRole())) {
            user.setRole(merchantUserRoleDao.getAdminRoleId().getId());
        }
        user.setParentUserId(merchantUser.getId());
        user.setStatus(UserStatus.ACTIVE);
        user.setPassword(EncryptionDecryptionUtil.hashValue(password));
        user.setPasswordExpiryTime(DateTimeUtils.getFutureDateByMonth(merchantConfig.getPasswordExpiryMonths()));
    }

    private void setMerchantUserId(MerchantUser merchantUser, boolean isProfileUpdate) {
        MerchantUser dbMerchantUser = merchantUserRepository.findByUserNameAndStatusIn(merchantUser.getUserName(), List.of(UserStatus.ACTIVE)).orElseThrow(() -> new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "Active Merchant User")));
        merchantUser.setId(dbMerchantUser.getId());
        if (isProfileUpdate) {
            merchantUser.setRole(dbMerchantUser.getRole());
        }
    }

}

