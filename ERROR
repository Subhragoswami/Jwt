package com.epay.merchant.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.*;

/**
 * Class Name: ErrorDto
 * *
 * Description:
 * *
 * Author: V1017903(bhushan wadekar)
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */

@Getter
@Setter
@Builder
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorDto {
    private String errorCode;
    private String errorMessage;

}


if (StringUtils.isNotEmpty(merchantLoginRequest.getUserName())) {
                List<ErrorDto> errorMessages = (e instanceof ValidationException)
                        ? ((ValidationException) e).getErrorMessages()
                        : ((MerchantException) e).getErrorMessages();
                tokenService.updateMerchantUserForLogin(merchantLoginRequest.getUserName(), false, errorMessages.toString(), RequestType.LOGIN.getName());
            }
            log.error("Login Validation Failed for userName {} ", merchantLoginRequest.getUserName());
            throw e;

package com.epay.merchant.entity;

import jakarta.persistence.*;
import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.util.UUID;

@Entity
@Getter
@Setter
@Builder
@Table(name = "login_audit")
@AllArgsConstructor
@NoArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class LoginAudit {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    private UUID userId;
    private String requestType;
    private boolean status;
    private String reason;
    @CreatedDate
    private Long createdAt;
}

[com.epay.merchant.dto.ErrorDto@6259ca97]










-------------------------------------------------------------------------------


package com.epay.merchant.exception;

import com.epay.merchant.dto.ErrorDto;
import lombok.Getter;

import java.util.List;

/**
 * Class Name: MerchantException
 * *
 * Description:
 * *
 * Author: V1017903(bhushan wadekar)
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
@Getter
public class MerchantException extends RuntimeException {
    private String errorCode;
    private String errorMessage;
    private List<ErrorDto> errorMessages;

    /**
     * Parametrized constructor taking errorcode and errorMessage
     * @param errorCode String
     * @param errorMessage String
     */
    public MerchantException(String errorCode, String errorMessage) {
        super(errorMessage);
        this.errorCode = errorCode;
        this.errorMessage = errorMessage;
    }

    /**
     * Parametrized constructor taking List of ErrorDTO
     * @param errorMessages List<ErrorDto>
     */
    public MerchantException(List<ErrorDto> errorMessages) {
        this.errorMessages = errorMessages;
    }

}


     if (StringUtils.isNotEmpty(merchantLoginRequest.getUserName())) {
                List<ErrorDto> errorMessages = (e instanceof ValidationException)
                        ? ((ValidationException) e).getErrorMessages()
                        : ((MerchantException) e).getErrorMessages();
                String errorMessage = convertErrorMessage(errorMessages);
                tokenService.updateMerchantUserForLogin(merchantLoginRequest.getUserName(), false, errorMessage, RequestType.LOGIN.getName());
            }



----------------------------------------------




package com.epay.merchant.exception;

import com.epay.merchant.dto.ErrorDto;
import lombok.Getter;

import java.util.List;

/**
 * Class Name: ValidationException
 * *
 * Description:
 * *
 * Author: V1017903(bhushan wadekar)
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
@Getter
public class ValidationException extends RuntimeException {

    private String errorCode;
    private String errorMessage;
    private List<ErrorDto> errorMessages;

    /**
     * Parametrized constructor taking errorcode and errorMessage
     * @param errorCode String
     * @param errorMessage String
     */
    public ValidationException(String errorCode, String errorMessage) {
        super(errorMessage);
        this.errorCode = errorCode;
        this.errorMessage = errorMessage;
    }

    /**
     * Parametrized constructor taking List of ErrorDTO
     * @param errorMessages List
     */
    public ValidationException(List<ErrorDto> errorMessages) {
        this.errorMessages = errorMessages;
    }

}




package com.epay.merchant.service;

import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.exception.ValidationException;
import com.epay.merchant.model.request.MerchantLoginRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.util.enums.RequestType;
import com.epay.merchant.validator.MerchantLoginValidator;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Service;

import java.text.MessageFormat;
import java.util.List;

/**
 * Class Name: LoginService
 * *
 * Description: Validate the UserName and Password to login
 * *
 * Author: Ravi Rathore
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */

@Service
@RequiredArgsConstructor
public class LoginService {

    private final MerchantLoginValidator merchantLoginValidator;
    private final TokenService tokenService;
    private final ObjectMapper objectMapper;
    LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    /**
     * Validates the user based on the provided validation request.
     *
     * @param merchantLoginRequest the login validation request containing user login details with captcha.
     * @return MerchantResponse containing success or failure details.
     */
    public MerchantResponse<String> merchantLogin(MerchantLoginRequest merchantLoginRequest) {
        try {
            merchantLoginValidator.validateMerchantLoginRequest(merchantLoginRequest);
            return MerchantResponse.<String>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of(MessageFormat.format(MerchantConstant.SUCCESS_MESSAGE, "Login User Found"))).build();
        } catch (ValidationException | MerchantException e) {
            if (StringUtils.isNotEmpty(merchantLoginRequest.getUserName())) {
                List<ErrorDto> errorMessages = (e instanceof ValidationException)
                        ? ((ValidationException) e).getErrorMessages()
                        : ((MerchantException) e).getErrorMessages();
                String errorMessage = convertErrorMessage(errorMessages);
                tokenService.updateMerchantUserForLogin(merchantLoginRequest.getUserName(), false, errorMessage, RequestType.LOGIN.getName());
            }
            log.error("Login Validation Failed for userName {} ", merchantLoginRequest.getUserName());
            throw e;
        } catch (Exception e) {
            tokenService.updateMerchantUserForLogin(merchantLoginRequest.getUserName(), false, e.getMessage(), RequestType.LOGIN.getName());
            log.error("Login Validation Failed for userName {} ", merchantLoginRequest.getUserName(), e.getMessage());
            throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE, ErrorConstants.GENERATION_ERROR_MESSAGE);
        }
    }

    private String convertErrorMessage(List<ErrorDto> errorMessages){
        try {
            return objectMapper.writeValueAsString(errorMessages);
        }catch (JsonProcessingException e){
           throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE, ErrorConstants.GENERATION_ERROR_MESSAGE)  ;
        }
    }

}









private String convertErrorMessage(Exception e) {
    ObjectMapper objectMapper = new ObjectMapper();
    List<ErrorDto> errorMessages = null;
    String errorCode = null;
    String errorMessage = null;

    // Extract relevant data based on exception type
    if (e instanceof ValidationException) {
        ValidationException validationException = (ValidationException) e;
        errorMessages = validationException.getErrorMessages();
        errorCode = validationException.getErrorCode();
        errorMessage = validationException.getErrorMessage();
    } else if (e instanceof MerchantException) {
        MerchantException merchantException = (MerchantException) e;
        errorMessages = merchantException.getErrorMessages();
        errorCode = merchantException.getErrorCode();
        errorMessage = merchantException.getErrorMessage();
    }

    // Serialize errorMessages if available
    if (errorMessages != null && !errorMessages.isEmpty()) {
        try {
            return objectMapper.writeValueAsString(errorMessages);
        } catch (JsonProcessingException ex) {
            log.error("Failed to serialize error messages: {}", ex.getMessage());
            return "[]"; // Default to an empty JSON array
        }
    }

    // Fallback to errorCode and errorMessage if errorMessages is null
    if (errorCode != null && errorMessage != null) {
        return String.format("{\"errorCode\":\"%s\",\"errorMessage\":\"%s\"}", errorCode, errorMessage);
    }

    // Default fallback for unknown cases
    return "{\"errorCode\":\"UNKNOWN\",\"errorMessage\":\"Unknown error occurred\"}";
}

